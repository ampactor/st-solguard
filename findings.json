[
  {
    "title": "Depositor can supply arbitrary Merkle root — no on-chain tree verification",
    "severity": "Critical",
    "description": "The deposit instruction accepts a new_root directly from user-supplied instruction data and stores it in the pool state without any verification. There is no on-chain Merkle tree — the program blindly trusts that the depositor computed the correct root after inserting their commitment. An attacker can deposit a minimal amount (e.g., 1 lamport) while submitting a fabricated Merkle root that includes a commitment for an arbitrarily large amount. They can then generate a valid ZK proof against this fabricated root and withdraw far more SOL than they deposited, draining the vault.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/deposit.rs",
    "line_number": 32,
    "remediation": "Implement an on-chain Merkle tree. The commitment should be inserted into the tree by the program itself, and the new root should be computed on-chain rather than accepted from the user.",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — deposit.rs:32-34 parses new_root from instruction data, deposit.rs:71 stores it via state.add_root() with zero verification. The _commitment field (underscore prefix) is never used."
  },
  {
    "title": "ZK circuit does not bind recipient to the commitment — recipient is unconstrained",
    "severity": "Critical",
    "description": "The Noir circuit's only constraint on the recipient public input is assert(recipient != 0). The recipient is not hashed into the commitment, not used in the nullifier derivation, and not otherwise constrained by any private inputs. A malicious relayer can substitute any recipient they choose because the circuit does not bind the recipient.",
    "file_path": "repos/shielded-pool-pinocchio-solana/noir_circuit/src/main.nr",
    "line_number": 53,
    "remediation": "Include the recipient in the commitment hash: commitment = H(secret, nullifier_key, amount, recipient).",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — main.nr:53 shows assert(recipient != 0) as the ONLY constraint, main.nr:42 shows commitment = H(secret, nullifier_key, amount) with recipient excluded."
  },
  {
    "title": "Deposit commitment is never verified or stored — no on-chain commitment tracking",
    "severity": "Critical",
    "description": "The deposit instruction parses the commitment from instruction data (stored as _commitment with underscore prefix) but never uses it. The commitment is not stored on-chain, not inserted into any Merkle tree, and not verified against the new_root. This is the root enabler for the arbitrary-root vulnerability.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/deposit.rs",
    "line_number": 29,
    "remediation": "Store commitments on-chain in a Merkle tree account. Verify that the new_root is the result of inserting the provided commitment into the current tree state.",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — deposit.rs:29-31 assigns let _commitment: [u8; 32] with underscore prefix (Rust convention for intentionally unused), deposit.rs:71 only uses new_root."
  },
  {
    "title": "Zero-amount deposits allow free Merkle root manipulation",
    "severity": "High",
    "description": "The deposit instruction does not validate that the transfer amount is greater than zero. An attacker can flush all legitimate roots out of the 32-entry circular history buffer by making 32 zero-amount deposits with garbage roots, breaking pending withdrawals. Combined with C-01, enables free vault drain.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/deposit.rs",
    "line_number": 26,
    "remediation": "Add check: if amount == 0 { return Err(ProgramError::InvalidInstructionData); }",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — deposit.rs:26-28 parses amount but never checks > 0, deposit.rs:39-44 SystemTransfer with amount=0 succeeds on Solana."
  },
  {
    "title": "Nullifier double-spend check relies on lamports instead of account existence flag",
    "severity": "High",
    "description": "The nullifier double-spend check uses nullifier_account.lamports() > 0 to determine if a nullifier has been used. Nullifier accounts are created with space=0. If any future instruction closes nullifier accounts, double-spending becomes possible.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/withdraw.rs",
    "line_number": 98,
    "remediation": "Allocate at least 1 byte of space for nullifier accounts and write a flag byte upon creation. Check for the flag byte's presence.",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — withdraw.rs:98-101 uses lamports() > 0 as guard, withdraw.rs:144-151 creates nullifier with space=0."
  },
  {
    "title": "Vault SOL withdrawal uses direct lamport manipulation instead of system program CPI",
    "severity": "Medium",
    "description": "The withdrawal of SOL from the vault directly modifies lamport balances via set_lamports() instead of using a System Program transfer CPI with PDA signing, bypassing Solana runtime safety checks.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/withdraw.rs",
    "line_number": 173,
    "remediation": "Use System Program transfer via CPI with PDA signing for the vault.",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — withdraw.rs:173-176 decrements vault lamports directly, withdraw.rs:177-180 increments recipient lamports directly."
  },
  {
    "title": "State PDA not validated in withdraw instruction",
    "severity": "Medium",
    "description": "The withdraw instruction checks that state_account is owned by the program and initialized, but does NOT verify that its address matches the expected PDA derived from seeds [b'pool_state']. Unlike deposit and initialize which check PDA derivation.",
    "file_path": "repos/shielded-pool-pinocchio-solana/shielded_pool_program/src/instructions/withdraw.rs",
    "line_number": 49,
    "remediation": "Add PDA derivation check in withdraw, matching the pattern used in deposit.rs:47-49 and initialize.rs:26-29.",
    "validation_status": "Confirmed",
    "validation_reasoning": "Manually verified in T32 clean-room analysis — withdraw.rs:49-50 only checks owned_by, deposit.rs:47-49 additionally checks PDA derivation."
  }
]
